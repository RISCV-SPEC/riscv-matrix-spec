[[intro]]
== Introduction

This document describes the matrix extension for RISC-V. 

Matrix extension implement matrix multiplications by partitioning the input and output matrix into tiles, which are then stored to matrix registers.

Tile size usually refers to the dimensions of these tiles. For the operation C = AB in figure below, the tile size of C is mtilem × mtilen, the tile size of A is mtilem × mtilek and the tile size of B is mtilek × mtilen. 

image::tiled-matmul.svg[Tiled Matrix Multiplication]

Each matrix multiplication instruction computes its output tile by stepping through the K dimension in tiles, loading the required values from the A and B matrices, and multiplying and accumulating them into the output.

Matrix extension is strongly inspired by the RISC-V Vector "V" extension.

== Implementation-defined Constant Parameters

Each hart supporting a matrix extension defines three parameters:

. The maximum size in bits of a matrix element that any operation can produce or consume, stem:[\rm{ELEN} \ge 8], which must be a power of 2.
. The number of bits in a single matrix tile register, MLEN, which must be a power of 2, and must be no greater than 2^32^.
. The number of bits in a row of a single matrix tile register, RLEN, which must be a power of 2, and must be no greater than 2^16^.
. ELEN < RLEN < MLEN, this supports matrix tile size from stem:[2 \times 2] to stem:[2^{16} \times 2^{16}].


== Programmer's Model

The matrix extension adds 8 matrix registers, and 8 unprivileged CSRs to the base scalar RISC-V ISA.

.Matrix CSRs
[cols="^2,^2,^2,10",options="header"]
|===
| Address | Privilege | Name   | Description

| 0xXXX | URO | mtype  | Matrix tile data type register.
| 0xXXX | URO | mlenb  | MLEN/8 (matrix tile register length in bytes).
| 0xXXX | URO | mrlenb | RLEN/8 (matrix tile register row length in bytes).
| 0xXXX | URO | mtilem | Tile length in m direction.
| 0xXXX | URO | mtilen | Tile length in n direction.
| 0xXXX | URO | mtilek | Tile length in k direction.
| 0xXXX | URW | mstart | Start element index.
| 0xXXX | URW | mcsr   | Matrix control and status register.
|===


=== Matrix Registers

The matrix extension adds 8 architectural **Tile Registers** (tr0-tr7) for input and output tile matrices.

A **Tile Register** has a fixed MLEN bits of state, where each row has RLEN bits. As a result, there are MLEN/RLEN rows for each tile register in logic.

image::registers.svg[alt="Matrix Registers", align="center"]

An input matrix of matrix multipliaction instruction only uses one tile register, and large matrix must be split according to the size of tile.

For widening instructions, each output element is wider than input one. An implementation should support double-width output and quad-width output.
To match the width of input and output, an output matrix may be written back to several registers: 2 registers for double-width output and 4 registers for quad-width output.

Widening instructions use continuous registers as their destination. For example, a double-widen instruction uses `td` and `td+1` as the output registers. As a result, the destination register index must be even (i.e., tr0/tr2/tr4/tr6). Odd-indexed `td` is reserved. A quad-widen instruction uses `td`, `td+1`, `td+2` and `td+3` as the output registers. As a result, the destination register index must be a multiple of 4 (i.e., tr0/tr4). Other-indexed `td` is reserved.

NOTE: Although there may be multiple output registers, the result can only be accessed by the first index.

=== Matrix Type Register, mtype

The read-only XLEN-wide _matrix_ _type_ CSR, `mtype`, provides the default type used to interpret the contents of the matrix register file, and can only be updated by `msettype{i}` instructions. The matrix type determines the organization of elements in each matrix register.

NOTE: Allowing updates only via the `msettype{i}` instructions simplifies maintenance of the `mtype` register state.

include::mtype.adoc[]

The `mfp64` field is set to support 64-bit float point. To support FP64 format, the implementation should support "D" extension at the same time. If the implementation does not support FP64 but `mfp64` is set to 1, `mtype.mill` will be set to indicate such an exception.

The `mlmul` field sets the group size of input register. Load/store and element-wise instructions support grouped input and output, so that a single instruction can operate on multiple tile registers. Different from matrix multiplication instructions, load/store and element-wise instructions can be pipelined in element or row level. There is no order limit across elements and rows. So grouped operation can provide great efficiency with acceptable complexity.

NOTE: For widen-output instructions, the group size of output cannot be larger than 4.

The `mba` bit indicates that the out-of-bound elements is undisturbed or agnostic. When `mba` is marked undisturbed (`mba=0`), the out-of-bound elements in a tile register retain the value they previously held. Otherwise, the out-of-bound elements can be overwritten with any values.

.`mlmul` field of `mtype`
[cols="^2,^2"]
|===
|     mlmul[1:0] | Group Size

|     2'b00 | 1
|     2'b01 | 2
|     2'b10 | 4
|     2'b11 | Reserved.
|===

The LMUL can also be specified by the `lmul` field of an instruction, with higher priority than `mtype` setting.

.`lmul` field of instruction
[cols="^2,^2"]
|===
|     lmul[1:0] | Group Size

|     2'b00 | 1
|     2'b01 | 2
|     2'b10 | 4
|     2'b11 | Use `mtype.mlmul`.
|===

NOTE: The `lmul` field of instruction provides a more efficient way for grouped operation, avoiding extra configuration instructions and possible misprediction of speculative CSR settings.

=== Matrix Tile Size Registers, mtilem/mtilek/mtilen

The XLEN-bit-wide read-only `mtilem/mtilek/mtilen` CSRs can only be updated by the `msettile{m|k|n}{i}` instructions. The registers holds 3 unsigned integers specifying the tile shapes for tiled matrix.


=== Matrix Start Index Register, mstart

The `mstart` read-write CSR specifies the index of the first element to be executed by load/store and element-wise arithmetic instructions. The CSR can be written by hardware on a trap, and its value represents the element on which the trap was taken. The value is the sequential number in row order.

Any legal matrix instruction can reset the `mstart` to zero at the end of excution.

=== Matrix Control and Status Register, mcsr

The `mcsr` register only has 1 field, and other bits with non-zero value are reserved.

.`mcsr` register layout
[cols="^2,^2,8"]
|===
|     Bits | Name       | Description

| XLEN-1:1 | 0          | Reserved if non-zero.
|        0 | mxsat      | Integer arithmetic instruction accrued saturation flag.
|===

=== Matrix Context Status in mstatus and sstatus

A 2-bit matrix context status field should be added to mstatus and shadowed in status. It is defined analogously to the vector context status field, VS.


== Instructions

=== Instruction Formats

The instructions in the matrix extension use a new major opcode (1110111, which inst[6:5]=11, inst[4:2]=101 is reserved in RISC-V opcode map).

This instruction formats are listed below.

Configuration instructions (funct3 = 111).

[cols="^2,^2,^2,^2,^2,^2,^3"]
|===
| **31 28** 2+| 27      20  | 19 15 | 14  12 | 11 7 | 6     0
|funct4     3+| imm13               | funct3 | rd   | 1110111
|funct4     2+| 00000000    | rs1   | funct3 | rd   | 1110111
|===

Data Move instructions (funct3 = 101), where `di` field indicates the moving direction.

[cols="^3,^1,^2,^2,^2,^2,^3"]
|===
| **31  26** | 25   | 24      20 | 19   15 | 14  12 | 11  7 | 6     0
| funct6     | di   | rs2/funct5 | ts1/rs1 | funct3 | td/rd | 1110111
|===

Load & Store instructions (ew = 000 - 011), where `ls` field indicates the type (load or store) and `lmul` field indicates the group size.

[cols="^3,^1,^2,^2,^2,^2,^2,^3"]
|===
| **31  26** | 25  | 24 20 | 19 15 | 14  12 | 11 10 | 9  7 | 6     0
| funct6     | ls  | rs2   | rs1   | eew    | lmul  | td   | 1110111
|===

Arithmetic & Type-Convert instructions (funct3 = 110), where `fp` field indicates the type (float or integer), `sn` field indicates the sign extension rule and `sa` field indicates saturated or unsaturated operation.

[cols="^2,^1,^2,^1,^1,^2,^2,^2,^2,^3"]
|===
| **31  26** | 25  | 24   20 | 19 | 18 | 17 15 | 14  12 | 11 10 | 9  7 | 6     0
| funct6     | fp  | ts2/rs2 | sn | sa | ts1   | funct3 | lmul  | td   | 1110111
|===


=== Configuration-Setting Instructions

Due to hardware resource constraints, one of the common ways to handle large-sized matrix multiplications is "tiling", where each iteration of the loop processes a subset of elements, and then continues to iterate until all elements are processed. The Matrix extension provides direct, portable support for this approach.

The block processing of matrix multiplication requires three levels of loops to iterate in the direction of the number of rows of the left matrix (m), the number of columns of the left matrix(k, also the number of rows of the right matrix), and the number of columns of the right matrix(n), given by the application. 

The shapes of the matrix tiles to be processed, m(application tile length m or `ATM`), k(`ATK`), n(`ATN`), is used as candidates for `mtilem/mtilek/mtilen`. Based on microarchitecture implementation and mtype setting, hardware returns a new `mtilem/mtilek/mtilen` value via a general purpose register (usually smaller), also stored in `mtilem/mtilek/mtilen` CSR, which is the shape of tile per iteration handled by hardware. 

For a simple matrix multiplication example, check out the Section Intrinsic Example, which describes how the code keeps track of the matrices processed by the hardware each iteration.


A set of instructions is provided to allow rapid configuration of the values in tile_* and mtype to match application needs. 

The `msettype{i}` instructions set the `mtype` CSR based on their arguments, and write the new value of mtype into rd.

```
msettypei rd, mtypei               # rd = new mtype, mtypei = new mtype setting
msettype rd, rs1                   # rd = new mtype, rs1 = new mtype value
```

The `msettile[m|k|n]{i}` instructions set the mtilem/mtilek/mtilen CSRs based on their arguments, and write the new value into rd.

```
msettilemi rd, mleni               # rd = new mtilem, mleni = ATM
msettilem rd, rs1                  # rd = new mtilem, rs1 = ATM
msettileki rd, mleni               # rd = new mtilek, mleni = ATN
msettilek rd, rs1                  # rd = new mtilek, rs1 = ATN
msettileni rd, mleni               # rd = new mtilen, mleni = ATK
msettilen rd, rs1                  # rd = new mtilen, rs1 = ATK
```

The `msettile` instruction sets the mtilem/mtilek/mtilen CSRs simultaneously, where the values are combined to rs1, and write the combined new values into rd.

```
msettile rd, rs1                   # rd[7:0] = new mtilem, rd[15:8] = new mtilen,
                                   # rd[XLEN-1:16] = new mtilek;
                                   # rs1[7:0] = ATM, rs1[15:8] = ATN,
                                   # rs1[XLEN-1:16] = ATK
```

To use the combined set instruction, the values of ATM and ATN must be held by 8 bits, and the value of ATK must be held by `XLEN-16` bits.

==== `mtype` Encoding

include::mtype.adoc[]

The new `mtype` value is encoded in the immediate fields of msettypei, and in the rs1 register for msettype.

```
Suggested assembler names used for msettypei mtypei immediate

    e8    # SEW = 8b
    e16   # SEW = 16b
    e32   # SEW = 32b
    e64   # SEW = 64b

    m1    # LMUL = 1 (mlmul = 00)
    m2    # LMUL = 2 (mlmul = 01)
    m4    # LMUL = 4 (mlmul = 10)

    ba    # Out-of-bound agnostic
    bu    # Out-of-bound undisturbed

    fp64  # support 64-bit float point

Examples:

    msettypei t0, e8                 # SEW = 8
    msettypei t0, e16, m2            # SEW = 16, LMUL = 2
    msettypei t0, e32, bu            # SEW = 16, out-of-bound undisturbed
    msettypei t0, e32, m4, ba        # SEW = 32, LMUL = 4, out-of-bound agnostic

    msettypei t0, e64, fp64          # SEW = 64, support 64-bit float point
```


==== `ATM/ATK/ATN` Encoding

There are three values, `TMMAX`, `TKMAX` and `TNMAX`, represents the maximum shapes of the matrix tiles could be stored in matrix registers, that can be operated on with a single matrix instruction given the current SEW settings.

The values of `TMMAX`, `TKMAX` and `TNMAX` are related to MLEN, RLEN and the micro-architecture of implementation.

// * TMMAX = MLEN / RLEN
// * TKMAX = min(MLEN / RLEN, RLEN / SEW)
// * TNMAX = RLEN / SEW

For examples, with MLEN=256 and RLEN=64, possible `TMMAX`, `TKMAX`, `TNMAX` values are shown below.

```
SEW=8,  TMMAX=4, TKMAX=4, TNMAX=8       # 4x4x8 8bit matmul
SEW=16, TMMAX=4, TKMAX=4, TNMAX=4       # 4x4x4 16bit matmul
SEW=32, TMMAX=4, TKMAX=2, TNMAX=2       # 4x2x2 32bit matmul
```

The new tile shape settings are based on `ATM/ATK/ATN` values, which for `msettile{m|k|n}` is encoded in the rs1 and rd fields.

[cols="^1,^1,<4,<5"]
|===
| rd  | rs1   | `ATM/ATK/ATN` value             | Effect on `mtilem/mtilek/mtilen`
| -   | !x0   | Value in `x[rs1]`               | Normal tiling
| !x0 | x0    | ~0                              | Set `mtilem/mtilek/mtilen` to `TMMAX/TKMAX/TNMAX`
| x0  | x0    | Value in `mtilem/mtilek/mtilen` | Keep existing `mtilem/mtilek/mtilen` if less than `TMMAX/TKMAX/TNMAX`
|===

For the `msettile[m|k|n]i` instructions, the `ATM/ATK/ATN` is encoded as a 13-bit zero-extended immediate in the rs1.

==== Constraints on Setting `mtilem/mtilek/mtilen`

The `msettile{m|k|n}{i}` instructions first set `TMMAX/TKMAX/TNMAX` according to the mtype CSR, then set `mtilem/mtilek/mtilen` obeying the following constraints (using `mtilem&ATM&TMMAX` as an example, and the same with `mtilek&ATK&TKMAX` and `mtilen&ATN&TNMAX`):

. `mtilem = ATM` if `ATM \<= TMMAX`
. `ceil(ATM / 2) \<= mtilem \<= TMMAX` if `ATM < (2 * TMMAX)`
. `mtilem = TMMAX` if `ATM >= (2 * TMMAX)`
. Deterministic on any given implementation for same input ATM and TMMAX values
. These specific properties follow from the prior rules:
.. `mtilem = 0` if `ATM = 0`
.. `mtilem > 0` if `ATM > 0`
.. `mtilem \<= TMMAX`
.. `mtilem \<= ATM`
.. a value read from `mtilem` when used as the ATM argument to `msettile{m|k|n}{i}` results in the same
value in `mtilem`, provided the resultant TMMAX equals the value of TMMAX at the time that `mtilem` was read.


Continue to use MLEN=256, RLEN=64 as a example. When SEW=16, TMMAX=4, TKMAX=4, TNMAX=8.

If A is a 7 x 8 matrix and B is a 8 x 14 matrix, we could get `mtilem/mtilek/mtilen` values as show below, in the last loop of tiling.

image::tiled-matmul-example.svg[Tiled Matrix Multiplication Example]


=== Load and Store Instructions

==== Load Instructions

Load a matrix tile from memory.

```
# td destination, rs1 base address, rs2 row byte stride

# For left matrix, A
# tile size = mtilem * mtilek
mlae8.m  td, (rs1), rs2, lmul   #  8-bit left tile load
mlae16.m td, (rs1), rs2, lmul   # 16-bit left tile load
mlae32.m td, (rs1), rs2, lmul   # 32-bit left tile load
mlae64.m td, (rs1), rs2, lmul   # 64-bit left tile load

# For right matrix, B
# tile size = mtilek * mtilen
mlbe8.m  td, (rs1), rs2, lmul   #  8-bit right tile load
mlbe16.m td, (rs1), rs2, lmul   # 16-bit right tile load
mlbe32.m td, (rs1), rs2, lmul   # 32-bit right tile load
mlbe64.m td, (rs1), rs2, lmul   # 64-bit right tile load

# For output matrix, C
# tile size = mtilem * mtilen
mlce8.m  td, (rs1), rs2, lmul   #  8-bit output tile load
mlce16.m td, (rs1), rs2, lmul   # 16-bit output tile load
mlce32.m td, (rs1), rs2, lmul   # 32-bit output tile load
mlce64.m td, (rs1), rs2, lmul   # 64-bit output tile load

```

Load a matrix tile from memory, the matrix on memory is transposed.

```
# td destination, rs1 base address, rs2 row byte stride

# For left matrix, A
# tile size = mtilek * mtilem
mlate8.m  td, (rs1), rs2, lmul  #  8-bit left tile load
mlate16.m td, (rs1), rs2, lmul  # 16-bit left tile load
mlate32.m td, (rs1), rs2, lmul  # 32-bit left tile load
mlate64.m td, (rs1), rs2, lmul  # 64-bit left tile load

# For right matrix, B
# tile size = mtilen * mtilek
mlbte8.m  td, (rs1), rs2, lmul  #  8-bit right tile load
mlbte16.m td, (rs1), rs2, lmul  # 16-bit right tile load
mlbte32.m td, (rs1), rs2, lmul  # 32-bit right tile load
mlbte64.m td, (rs1), rs2, lmul  # 64-bit right tile load

# For output matrix, C
# tile size = mtilen * mtilem
mlcte8.m  td, (rs1), rs2, lmul  #  8-bit output tile load
mlcte16.m td, (rs1), rs2, lmul  # 16-bit output tile load
mlcte32.m td, (rs1), rs2, lmul  # 32-bit output tile load
mlcte64.m td, (rs1), rs2, lmul  # 64-bit output tile load

```

==== Store Instructions

Store a matrix tile to memory.

```
# ts3 store data, rs1 base address, rs2 row byte stride

# For left matrix, A
# tile size = mtilem * mtilek
msae8.m  ts3, (rs1), rs2, lmul  #  8-bit left tile store
msae16.m ts3, (rs1), rs2, lmul  # 16-bit left tile store
msae32.m ts3, (rs1), rs2, lmul  # 32-bit left tile store
msae64.m ts3, (rs1), rs2, lmul  # 64-bit left tile store

# For right matrix, B
# tile size = mtilek * mtilen
msbe8.m  ts3, (rs1), rs2, lmul  #  8-bit right tile store
msbe16.m ts3, (rs1), rs2, lmul  # 16-bit right tile store
msbe32.m ts3, (rs1), rs2, lmul  # 32-bit right tile store
msbe64.m ts3, (rs1), rs2, lmul  # 64-bit right tile store

# For output matrix, C
# tile size = mtilem * mtilen
msce8.m  ts3, (rs1), rs2, lmul  #  8-bit output tile store
msce16.m ts3, (rs1), rs2, lmul  # 16-bit output tile store
msce32.m ts3, (rs1), rs2, lmul  # 32-bit output tile store
msce64.m ts3, (rs1), rs2, lmul  # 64-bit output tile store

```

Save a matrix tile to memory, the matrix on memory is transposed.

```
# ts3 store data, rs1 base address, rs2 row byte stride

# For left matrix, A
# tile size = mtilek * mtilem
msate8.m  ts3, (rs1), rs2, lmul #  8-bit left tile store
msate16.m ts3, (rs1), rs2, lmul # 16-bit left tile store
msate32.m ts3, (rs1), rs2, lmul # 32-bit left tile store
msate64.m ts3, (rs1), rs2, lmul # 64-bit left tile store

# For right matrix, B
# tile size = mtilen * mtilek
msbte8.m  ts3, (rs1), rs2, lmul #  8-bit right tile store
msbte16.m ts3, (rs1), rs2, lmul # 16-bit right tile store
msbte32.m ts3, (rs1), rs2, lmul # 32-bit right tile store
msbte64.m ts3, (rs1), rs2, lmul # 64-bit right tile store

# For output matrix, C
# tile size = mtilen * mtilem
mscte8.m  ts3, (rs1), rs2, lmul #  8-bit output tile store
mscte16.m ts3, (rs1), rs2, lmul # 16-bit output tile store
mscte32.m ts3, (rs1), rs2, lmul # 32-bit output tile store
mscte64.m ts3, (rs1), rs2, lmul # 64-bit output tile store
```

==== Whole Matrix Load & Store Instructions

Load a whole matrix from memory without considering the tile size.

```
mlre8.m  td, (rs1), rs2, lmul   #  8-bit whole matrix load
mlre16.m td, (rs1), rs2, lmul   # 16-bit whole matrix load
mlre32.m td, (rs1), rs2, lmul   # 32-bit whole matrix load
mlre64.m td, (rs1), rs2, lmul   # 64-bit whole matrix load
```

Store a whole matrix to memory without considering the tile size.

```
msre8.m  ts3, (rs1), rs2, lmul  #  8-bit whole matrix store
msre16.m ts3, (rs1), rs2, lmul  # 16-bit whole matrix store
msre32.m ts3, (rs1), rs2, lmul  # 32-bit whole matrix store
msre64.m ts3, (rs1), rs2, lmul  # 64-bit whole matrix store
```

NOTE: Whole matrix load and store instructions are usually used for context saving and restoring, and no tranposed version is provided.

=== Data Move Instructions

The basic data move instructions are used to move single element between integer registers and tile registers. Such instructions can change a part of matrix and often used for debug.

```
# x[rd] = ts1[i, j], i = rs2[15:0], j = rs2[XLEN-1:16]
mmv.x.s rd, ts1, rs2

# td[i, j] = x[rs1], i = rs2[15:0], j = rs2[XLEN-1:16]
mmv.s.x td, rs1, rs2
```

The `mmv.x.s` instruction copies a signle SEW-wide element of the tile register to an integer register, where the element coordinates are specified by rs2. If SEW > XLEN, the least-significat XLEN bits are transferred. If SEW < XLEN, the valud is sign-extended to XLEN bits.

The `mmv.s.x` instruction copies an integer register to an element of the destination tile register, where the element coordinates are specified by rs2. If SEW < XLEN, the least-significant bits are moved and the upper (XLEN-SEW) bits are ignored. If SEW > XLEN, the valud is sign-extended to SEW bits. The other elements of the tile register are treated as out-of-bound elements, using the setting of `mtype.mba`.

Float point data move instructions are similar.

```
# f[rd] = ts1[i, j], i = rs2[15:0], j = rs2[XLEN-1:16]
mfmv.f.s rd, ts1, rs2

# td[i, j] = f[rs1], i = rs2[15:0], j = rs2[XLEN-1:16]
mfmv.s.f td, rs1, rs2
```

NOTE: The pseudo-instruction `mmv.m.m td, ts1` to move a whole matrix between two tile registers can be implemented as `memul.mi td, ts1, 1, m1`.

The first row/column and the first element of a tile register can be broadcasted to fill the whole matrix.

```
# Broadcast the first row to fill the whole matrix.
mbcar.m td, ts1
mbcbr.m td, ts1
mbccr.m td, ts1

# Broadcast the first column to fill the whole matrix.
mbcac.m td, ts1
mbcbc.m td, ts1
mbccc.m td, ts1

# Broadcast the first element to fill the whole matrix.
mbcae.m td, ts1
mbcbe.m td, ts1
mbcce.m td, ts1
```

=== Arithmetic Instructions

==== Matrix Multiplication Instructions

Matrix Multiplication operations take two matrix tiles from matrix **tile registers** specified by `ts1` and `ts2` respectively, and the output matrix tile is a matrix **tile register** specified by `td` or a group matrix **tile registers** started from `td`.

```
# Unigned integer matrix multiplication and add, td = td + ts1 * ts2
mmau.mm   td, ts1, ts2    
mwmau.mm  td, ts1, ts2  # output double widen
mqmau.mm  td, ts1, ts2  # output quadruple widen

msmau.mm  td, ts1, ts2  # saturated
mswmau.mm td, ts1, ts2  # saturated and output double widen
msqmau.mm td, ts1, ts2  # saturated and output quadruple widen

# Signed integer matrix multiplication and add, td = td + ts1 * ts2
mma.mm    td, ts1, ts2    
mwma.mm   td, ts1, ts2  # output double widen
mqma.mm   td, ts1, ts2  # output quadruple widen

msma.mm   td, ts1, ts2  # saturated
mswma.mm  td, ts1, ts2  # saturated and output double widen
msqma.mm  td, ts1, ts2  # saturated and output quadruple widen

# Float matrix multiplication and add, td = td + ts1 * ts2
mfma.mm   td, ts1, ts2
mfwma.mm  td, ts1, ts2  # output double widen
```

==== Element-Wise Add/Sub/Multiply Instructions

Matrix element-wise add/sub/multiply instructions. The input and output matrices are with size `mtilem x mtilen`.

```
# Unsigned integer matrix element-wise add. 
# td[i,j] = ts1[i,j] + ts2[i,j]
maddu.mm   td, ts1, ts2, lmul
msaddu.mm  td, ts1, ts2, lmul   # saturated
mwaddu.mm  td, ts1, ts2, lmul   # output double widen

# Signed integer matrix element-wise add.
# td[i,j] = ts1[i,j] + ts2[i,j]
madd.mm    td, ts1, ts2, lmul
msadd.mm   td, ts1, ts2, lmul   # saturated
mwadd.mm   td, ts1, ts2, lmul   # output double widen

# Unsigned integer matrix element-wise subtract.
# td[i,j] = ts1[i,j] - ts2[i,j]
msubu.mm   td, ts1, ts2, lmul
mssubu.mm  td, ts1, ts2, lmul   # saturated
mwsubu.mm  td, ts1, ts2, lmul   # output double widen

# Signed integer matrix element-wise subtract.
# td[i,j] = ts1[i,j] - ts2[i,j]
msub.mm    td, ts1, ts2, lmul
mwsub.mm   td, ts1, ts2, lmul   # output double widen
mssub.mm   td, ts1, ts2, lmul   # saturated

# Integer matrix element-wise minimum.
# td[i,j] = min{ts1[i,j], ts2[i,j]}
mminu.mm   td, ts1, ts2, lmul
mmin.mm    td, ts1, ts2, lmul

# Integer matrix element-wise maximum.
# td[i,j] = max{ts1[i,j], ts2[i,j]}
mmaxu.mm   td, ts1, ts2, lmul
mmax.mm    td, ts1, ts2, lmul

# Integer matrix element-wise multiply.
# td[i,j] = ts1[i,j] * ts2[i,j]
mmul.mm    td, ts1, ts2, lmul   # signed, returning low bits of product
mmulh.mm   td, ts1, ts2, lmul   # signed, returning high bits of product
mmulhu.mm  td, ts1, ts2, lmul   # unsigned, returning high bits of product
mmulhsu.mm td, ts1, ts2, lmul   # signed-unsigned, returning high bits of product

# Saturated integer matrix element-wise multiply.
msmul.mm   td, ts1, ts2, lmul   # signed
msmulu.mm  td, ts1, ts2, lmul   # unsigned
msmulsu.mm td, ts1, ts2, lmul   # signed-unsigned

# Widening integer matrix element-wise multiply.
mwmul.mm   td, ts1, ts2, lmul   # signed
mwmulu.mm  td, ts1, ts2, lmul   # unsigned
mwmulsu.mm td, ts1, ts2, lmul   # signed-unsigned

# Float matrix element-wise add.
# td[i,j] = ts1[i,j] + ts2[i,j]
mfadd.mm   td, ts1, ts2, lmul
mfwadd.mm  td, ts1, ts2, lmul   # output double widen

# Float matrix element-wise subtract.
# td[i,j] = ts1[i,j] - ts2[i,j]
mfsub.mm   td, ts1, ts2, lmul
mfwsub.mm  td, ts1, ts2, lmul   # output double widen

# Float matrix element-wise minimum.
# td[i,j] = min{ts1[i,j], ts2[i,j]}
mfmin.mm   td, ts1, ts2, lmul

# Float matrix element-wise maximum.
# td[i,j] = max{ts1[i,j], ts2[i,j]}
mfmax.mm   td, ts1, ts2, lmul

# Float matrix element-wise multiply.
# td[i,j] = ts1[i,j] * ts2[i,j]
mfmul.mm   td, ts1, ts2, lmul
mfwmul.mm  td, ts1, ts2, lmul   # output double widen

# Float matrix element-wise divide.
# td[i,j] = ts1[i,j] / ts2[i,j]
mfdiv.mm   td, ts1, ts2, lmul

# Float matrix element-wise square root.
# td[i,j] = ts1[i,j] ^ (1/2)
mfsqrt.m   td, ts1, lmul
```

NOTE: There is no matrix-scalar or matrix-vector version for element-wise instructions. Such operations can be replaced by a broadcast instruction and a matrix-matrix element-wise instruction.

==== Type-Convert Instructions

```
# Convert float to float
mfncvt.f.fw.m  td, ts1, lmul   # double-width float to single-width float
mfwcvt.fw.f.m  td, ts1, lmul   # single-width float to double-width float

# Convert integer to float
mfcvt.f.x.m    td, ts1, lmul   # integer to float

mfncvt.f.xw.m  td, ts1, lmul   # double-width integer to float
mfncvt.f.xq.m  td, ts1, lmul   # quad-width integer to float

mfwcvt.fw.x.m  td, ts1, lmul   # single-width integer to double-width float
mfcvt.fw.xw.m  td, ts1, lmul   # double-width integer to double-width float
mfncvt.fw.xq.m td, ts1, lmul   # quad-width integer to double-width float

# Convert float to integer
mfcvt.x.f.m    td, ts1, lmul   # float to integer

mfwcvt.xw.f.m  td, ts1, lmul   # float to double-width integer
mfwcvt.xq.f.m  td, ts1, lmul   # float to quad-width integer

mfncvt.x.fw.m  td, ts1, lmul   # double-width float to single-width integer
mfcvt.xw.fw.m  td, ts1, lmul   # double-width float to double-width integer
mfwcvt.xq.fw.m td, ts1, lmul   # double-width float to quad-width integer
```


=== Instruction Listing

[cols="^2,4,^3,^2,^2,^2,^2,^2,^3"]
|===
| No.  |            | **31 28** 2+| 27      20  | 19 15 | 14  12 | 11 7 | 6    0
2+|**Configuration**   ^|funct4 2+|             | rs1   | funct3 | rd   | opcode
| 1    | msettypei      | 0000  3+| mtypei[27:15]       | 111    | rd   | 1110111
| 2    | msettype       | 0001  2+| 00000000    | rs1   | 111    | rd   | 1110111
| 3    | msettilemi     | 0010  3+| mleni[27:15]        | 111    | rd   | 1110111
| 4    | msettilem      | 0011  2+| 00000000    | rs1   | 111    | rd   | 1110111
| 5    | msettileki     | 0100  3+| mleni[27:15]        | 111    | rd   | 1110111
| 6    | msettilek      | 0101  2+| 00000000    | rs1   | 111    | rd   | 1110111
| 7    | msettileni     | 0110  3+| mleni[27:15]        | 111    | rd   | 1110111
| 8    | msettilen      | 0111  2+| 00000000    | rs1   | 111    | rd   | 1110111
| 9    | msettile       | 1000  2+| 00000000    | rs1   | 111    | rd   | 1110111
9+|
|===

[cols="^2,4,^3,^2,^2,^2,^2,^2,^3"]
|===
| No.  |             | **31  26** | 25   | 24 20 | 19 15 | 14  12 | 11 7 | 6    0
2+|**Data Move**        ^| funct6 | di   | rs2   | *s1   | funct3 | *d   | opcode
| 1    | mmv.x.s         | 000000 | 0    | rs2   | ts1   | 101    | rd   | 1110111
| 2    | mmv.s.x         | 000000 | 1    | rs2   | rs1   | 101    | td   | 1110111
| 3    | mfmv.f.s        | 000001 | 0    | rs2   | ts1   | 101    | rd   | 1110111
| 4    | mfmv.s.f        | 000001 | 1    | rs2   | rs1   | 101    | td   | 1110111
| 5    | mbcar.m         | 000010 | 0    | 00001 | ts1   | 101    | td   | 1110111
| 6    | mbcbr.m         | 000010 | 0    | 00010 | ts1   | 101    | td   | 1110111
| 7    | mbccr.m         | 000010 | 0    | 00000 | ts1   | 101    | td   | 1110111
| 8    | mbcac.m         | 000010 | 0    | 00101 | ts1   | 101    | td   | 1110111
| 9    | mbcbc.m         | 000010 | 0    | 00110 | ts1   | 101    | td   | 1110111
| 10   | mbccc.m         | 000010 | 0    | 00100 | ts1   | 101    | td   | 1110111
| 11   | mbcae.m         | 000010 | 0    | 01001 | ts1   | 101    | td   | 1110111
| 12   | mbcbe.m         | 000010 | 0    | 01010 | ts1   | 101    | td   | 1110111
| 13   | mbcce.m         | 000010 | 0    | 01000 | ts1   | 101    | td   | 1110111
|===

[cols="^2,5,^3,^2,^2,^2,^2,^2,^2,^3"]
|===
| No.  |           | **31  26** | 25 | 24 20 | 19 15 | 14  12 | 11 10 | 9 7 | 6    0
2+|**Load**           ^| funct6 | ls | rs2   | rs1   | eew    | lmul  | td  | opcode
| 1    | mlae8.m       | 000001 | 0  | rs2   | rs1   | 000    | lmul  | td  | 1110111
| 2    | mlae16.m      | 000001 | 0  | rs2   | rs1   | 001    | lmul  | td  | 1110111
| 3    | mlae32.m      | 000001 | 0  | rs2   | rs1   | 010    | lmul  | td  | 1110111
| 4    | mlae64.m      | 000001 | 0  | rs2   | rs1   | 011    | lmul  | td  | 1110111
| 5    | mlbe8.m       | 000010 | 0  | rs2   | rs1   | 000    | lmul  | td  | 1110111
| 6    | mlbe16.m      | 000010 | 0  | rs2   | rs1   | 001    | lmul  | td  | 1110111
| 7    | mlbe32.m      | 000010 | 0  | rs2   | rs1   | 010    | lmul  | td  | 1110111
| 8    | mlbe64.m      | 000010 | 0  | rs2   | rs1   | 011    | lmul  | td  | 1110111
| 9    | mlce8.m       | 000000 | 0  | rs2   | rs1   | 000    | lmul  | td  | 1110111
| 10   | mlce16.m      | 000000 | 0  | rs2   | rs1   | 001    | lmul  | td  | 1110111
| 11   | mlce32.m      | 000000 | 0  | rs2   | rs1   | 010    | lmul  | td  | 1110111
| 12   | mlce64.m      | 000000 | 0  | rs2   | rs1   | 011    | lmul  | td  | 1110111
| 13   | mlre8.m       | 000011 | 0  | rs2   | rs1   | 000    | lmul  | td  | 1110111
| 14   | mlre16.m      | 000011 | 0  | rs2   | rs1   | 001    | lmul  | td  | 1110111
| 15   | mlre32.m      | 000011 | 0  | rs2   | rs1   | 010    | lmul  | td  | 1110111
| 16   | mlre64.m      | 000011 | 0  | rs2   | rs1   | 011    | lmul  | td  | 1110111

| 17   | mlate8.m      | 000101 | 0  | rs2   | rs1   | 000    | lmul  | td  | 1110111
| 18   | mlate16.m     | 000101 | 0  | rs2   | rs1   | 001    | lmul  | td  | 1110111
| 19   | mlate32.m     | 000101 | 0  | rs2   | rs1   | 010    | lmul  | td  | 1110111
| 20   | mlate64.m     | 000101 | 0  | rs2   | rs1   | 011    | lmul  | td  | 1110111
| 21   | mlbte8.m      | 000110 | 0  | rs2   | rs1   | 000    | lmul  | td  | 1110111
| 22   | mlbte16.m     | 000110 | 0  | rs2   | rs1   | 001    | lmul  | td  | 1110111
| 23   | mlbte32.m     | 000110 | 0  | rs2   | rs1   | 010    | lmul  | td  | 1110111
| 24   | mlbte64.m     | 000110 | 0  | rs2   | rs1   | 011    | lmul  | td  | 1110111
| 25   | mlcte8.m      | 000100 | 0  | rs2   | rs1   | 000    | lmul  | td  | 1110111
| 26   | mlcte16.m     | 000100 | 0  | rs2   | rs1   | 001    | lmul  | td  | 1110111
| 27   | mlcte32.m     | 000100 | 0  | rs2   | rs1   | 010    | lmul  | td  | 1110111
| 28   | mlcte64.m     | 000100 | 0  | rs2   | rs1   | 011    | lmul  | td  | 1110111

2+|**Store**          ^| funct6 | ls | rs2   | rs1   | eew    | lmul  | ts3 | opcode
| 1    | msae8.m       | 000001 | 1  | rs2   | rs1   | 000    | lmul  | ts3 | 1110111
| 2    | msae16.m      | 000001 | 1  | rs2   | rs1   | 001    | lmul  | ts3 | 1110111
| 3    | msae32.m      | 000001 | 1  | rs2   | rs1   | 010    | lmul  | ts3 | 1110111
| 4    | msae64.m      | 000001 | 1  | rs2   | rs1   | 011    | lmul  | ts3 | 1110111
| 5    | msbe8.m       | 000010 | 1  | rs2   | rs1   | 000    | lmul  | ts3 | 1110111
| 6    | msbe16.m      | 000010 | 1  | rs2   | rs1   | 001    | lmul  | ts3 | 1110111
| 7    | msbe32.m      | 000010 | 1  | rs2   | rs1   | 010    | lmul  | ts3 | 1110111
| 8    | msbe64.m      | 000010 | 1  | rs2   | rs1   | 011    | lmul  | ts3 | 1110111
| 9    | msce8.m       | 000000 | 1  | rs2   | rs1   | 000    | lmul  | ts3 | 1110111
| 10   | msce16.m      | 000000 | 1  | rs2   | rs1   | 001    | lmul  | ts3 | 1110111
| 11   | msce32.m      | 000000 | 1  | rs2   | rs1   | 010    | lmul  | ts3 | 1110111
| 12   | msce64.m      | 000000 | 1  | rs2   | rs1   | 011    | lmul  | ts3 | 1110111
| 13   | msre8.m       | 000011 | 1  | rs2   | rs1   | 000    | lmul  | ts3 | 1110111
| 14   | msre16.m      | 000011 | 1  | rs2   | rs1   | 001    | lmul  | ts3 | 1110111
| 15   | msre32.m      | 000011 | 1  | rs2   | rs1   | 010    | lmul  | ts3 | 1110111
| 16   | msre64.m      | 000011 | 1  | rs2   | rs1   | 011    | lmul  | ts3 | 1110111

| 17   | msate8.m      | 000101 | 1  | rs2   | rs1   | 000    | lmul  | ts3 | 1110111
| 18   | msate16.m     | 000101 | 1  | rs2   | rs1   | 001    | lmul  | ts3 | 1110111
| 19   | msate32.m     | 000101 | 1  | rs2   | rs1   | 010    | lmul  | ts3 | 1110111
| 20   | msate64.m     | 000101 | 1  | rs2   | rs1   | 011    | lmul  | ts3 | 1110111
| 21   | msbte8.m      | 000110 | 1  | rs2   | rs1   | 000    | lmul  | ts3 | 1110111
| 22   | msbte16.m     | 000110 | 1  | rs2   | rs1   | 001    | lmul  | ts3 | 1110111
| 23   | msbte32.m     | 000110 | 1  | rs2   | rs1   | 010    | lmul  | ts3 | 1110111
| 24   | msbte64.m     | 000110 | 1  | rs2   | rs1   | 011    | lmul  | ts3 | 1110111
| 25   | mscte8.m      | 000100 | 1  | rs2   | rs1   | 000    | lmul  | ts3 | 1110111
| 26   | mscte16.m     | 000100 | 1  | rs2   | rs1   | 001    | lmul  | ts3 | 1110111
| 27   | mscte32.m     | 000100 | 1  | rs2   | rs1   | 010    | lmul  | ts3 | 1110111
| 28   | mscte64.m     | 000100 | 1  | rs2   | rs1   | 011    | lmul  | ts3 | 1110111
|===

[cols="^3,7,^5,^2,^3,^2,^2,^3,^3,^3,^3,^5"]
|===
| No.  |           | **31  26** | 25 | 24 20 | 19 | 18 | 17 15 | 14  12 | 11 10 | 9 7 | 6    0
2+|**Arithmetic**     ^| funct6 | fp | *s2   | sn | sa | ts1   | funct3 | lmul  | td  | opcode
| 1    | mmau.mm       | 000000 | 0  | ts2   | 0  | 0  | ts1   | 110    | 00    | td  | 1110111
| 2    | msmau.mm      | 000000 | 0  | ts2   | 0  | 1  | ts1   | 110    | 00    | td  | 1110111
| 3    | mma.mm        | 000000 | 0  | ts2   | 1  | 0  | ts1   | 110    | 00    | td  | 1110111
| 4    | msma.mm       | 000000 | 0  | ts2   | 1  | 1  | ts1   | 110    | 00    | td  | 1110111
| 5    | mfma.mm       | 000000 | 1  | ts2   | 0  | 0  | ts1   | 110    | 00    | td  | 1110111
| 6    | mwmau.mm      | 000001 | 0  | ts2   | 0  | 0  | ts1   | 110    | 00    | td  | 1110111
| 7    | mswmau.mm     | 000001 | 0  | ts2   | 0  | 1  | ts1   | 110    | 00    | td  | 1110111
| 8    | mwma.mm       | 000001 | 0  | ts2   | 1  | 0  | ts1   | 110    | 00    | td  | 1110111
| 9    | mswma.mm      | 000001 | 0  | ts2   | 1  | 1  | ts1   | 110    | 00    | td  | 1110111
| 10   | mfwma.mm      | 000001 | 1  | ts2   | 0  | 0  | ts1   | 110    | 00    | td  | 1110111
| 11   | mqmau.mm      | 000010 | 0  | ts2   | 0  | 0  | ts1   | 110    | 00    | td  | 1110111
| 12   | msqmau.mm     | 000010 | 0  | ts2   | 0  | 1  | ts1   | 110    | 00    | td  | 1110111
| 13   | mqma.mm       | 000010 | 0  | ts2   | 1  | 0  | ts1   | 110    | 00    | td  | 1110111
| 14   | msqma.mm      | 000010 | 0  | ts2   | 1  | 1  | ts1   | 110    | 00    | td  | 1110111

| 15   | maddu.mm      | 000100 | 0  | ts2   | 0  | 0  | ts1   | 110    | lmul  | td  | 1110111
| 16   | msaddu.mm     | 000100 | 0  | ts2   | 0  | 1  | ts1   | 110    | lmul  | td  | 1110111
| 17   | madd.mm       | 000100 | 0  | ts2   | 1  | 0  | ts1   | 110    | lmul  | td  | 1110111
| 18   | msadd.mm      | 000100 | 0  | ts2   | 1  | 1  | ts1   | 110    | lmul  | td  | 1110111
| 19   | mfadd.mm      | 000100 | 1  | ts2   | 0  | 0  | ts1   | 110    | lmul  | td  | 1110111
| 20   | mwaddu.mm     | 000101 | 0  | ts2   | 0  | 0  | ts1   | 110    | lmul  | td  | 1110111
| 21   | mwadd.mm      | 000101 | 0  | ts2   | 1  | 0  | ts1   | 110    | lmul  | td  | 1110111
| 22   | mfwadd.mm     | 000101 | 1  | ts2   | 0  | 0  | ts1   | 110    | lmul  | td  | 1110111
| 23   | msubu.mm      | 000110 | 0  | ts2   | 0  | 0  | ts1   | 110    | lmul  | td  | 1110111
| 24   | mssubu.mm     | 000110 | 0  | ts2   | 0  | 1  | ts1   | 110    | lmul  | td  | 1110111
| 25   | msub.mm       | 000110 | 0  | ts2   | 1  | 0  | ts1   | 110    | lmul  | td  | 1110111
| 26   | mssub.mm      | 000110 | 0  | ts2   | 1  | 1  | ts1   | 110    | lmul  | td  | 1110111
| 27   | mfsub.mm      | 000110 | 1  | ts2   | 0  | 0  | ts1   | 110    | lmul  | td  | 1110111
| 28   | mwsubu.mm     | 000111 | 0  | ts2   | 0  | 0  | ts1   | 110    | lmul  | td  | 1110111
| 29   | mwsub.mm      | 000111 | 0  | ts2   | 1  | 0  | ts1   | 110    | lmul  | td  | 1110111
| 30   | mfwsub.mm     | 000111 | 1  | ts2   | 0  | 0  | ts1   | 110    | lmul  | td  | 1110111
| 31   | mminu.mm      | 001000 | 0  | ts2   | 0  | 0  | ts1   | 110    | lmul  | td  | 1110111
| 32   | mmin.mm       | 001000 | 0  | ts2   | 1  | 0  | ts1   | 110    | lmul  | td  | 1110111
| 33   | mfmin.mm      | 001000 | 1  | ts2   | 0  | 0  | ts1   | 110    | lmul  | td  | 1110111
| 34   | mmaxu.mm      | 001001 | 0  | ts2   | 0  | 0  | ts1   | 110    | lmul  | td  | 1110111
| 35   | mmax.mm       | 001001 | 0  | ts2   | 1  | 0  | ts1   | 110    | lmul  | td  | 1110111
| 36   | mfmax.mm      | 001001 | 1  | ts2   | 0  | 0  | ts1   | 110    | lmul  | td  | 1110111

| 38   | msmulu.mm     | 001010 | 0  | rs2   | 0  | 1  | ts1   | 110    | lmul  | td  | 1110111
| 37   | mmul.mm       | 001010 | 0  | rs2   | 1  | 0  | ts1   | 110    | lmul  | td  | 1110111
| 38   | msmul.mm      | 001010 | 0  | rs2   | 1  | 1  | ts1   | 110    | lmul  | td  | 1110111
| 39   | mfmul.mm      | 001010 | 1  | rs2   | 0  | 0  | ts1   | 110    | lmul  | td  | 1110111
| 40   | mmulhu.mm     | 001011 | 0  | rs2   | 0  | 0  | ts1   | 110    | lmul  | td  | 1110111
| 41   | mmulh.mm      | 001011 | 0  | rs2   | 1  | 0  | ts1   | 110    | lmul  | td  | 1110111
| 42   | mmulhsu.mm    | 001100 | 0  | rs2   | 0  | 0  | ts1   | 110    | lmul  | td  | 1110111
| 42   | msmulsu.mm    | 001100 | 0  | rs2   | 0  | 1  | ts1   | 110    | lmul  | td  | 1110111
| 43   | mwmulu.mm     | 001101 | 0  | rs2   | 0  | 0  | ts1   | 110    | lmul  | td  | 1110111
| 44   | mwmul.mm      | 001101 | 0  | rs2   | 1  | 0  | ts1   | 110    | lmul  | td  | 1110111
| 45   | mwmulsu.mm    | 001101 | 0  | rs2   | 1  | 1  | ts1   | 110    | lmul  | td  | 1110111
| 46   | mfwmul.mm     | 001101 | 1  | rs2   | 0  | 0  | ts1   | 110    | lmul  | td  | 1110111
| 47   | mfdiv.mm      | 001110 | 1  | rs2   | 0  | 0  | ts1   | 110    | lmul  | td  | 1110111
| 48   | mfsqrt.mm     | 001111 | 1  | 0..   | 0  | 0  | ts1   | 110    | lmul  | td  | 1110111
|===

[cols="^3,8,^5,^3,^3,^3,^4,^3,^3,^5"]
|===
| No.  |                 | **31 26** | 25   | 24 20 | 19 15 | 14  12 | 11 10 | 9 7 | 6    0
2+|**Convert**          ^| funct6    | fdst | 0     | ts1   | funct3 | lmul  | td  | opcode
| 1    | mfncvtc.f.fw.m  | 010000    | 1    | 0     | ts1   | 110    | lmul  | td  | 1110111
| 2    | mfwcvtc.fw.f.m  | 010000    | 0    | 0     | ts1   | 110    | lmul  | td  | 1110111
| 3    | mfcvtc.f.x.m    | 010010    | 1    | 0     | ts1   | 110    | lmul  | td  | 1110111
| 4    | mfcvtc.x.f.m    | 010010    | 0    | 0     | ts1   | 110    | lmul  | td  | 1110111
| 5    | mfncvtc.f.xw.m  | 010011    | 1    | 0     | ts1   | 110    | lmul  | td  | 1110111 
| 6    | mfwcvtc.xw.f.m  | 010011    | 0    | 0     | ts1   | 110    | lmul  | td  | 1110111 
| 7    | mfncvtc.f.xq.m  | 010100    | 1    | 0     | ts1   | 110    | lmul  | td  | 1110111
| 8    | mfwcvtc.xq.f.m  | 010100    | 0    | 0     | ts1   | 110    | lmul  | td  | 1110111
| 9    | mfwcvtc.fw.x.m  | 010101    | 1    | 0     | ts1   | 110    | lmul  | td  | 1110111
| 10   | mfncvtc.x.fw.m  | 010101    | 0    | 0     | ts1   | 110    | lmul  | td  | 1110111
| 11   | mfcvtc.fw.xw.m  | 010110    | 1    | 0     | ts1   | 110    | lmul  | td  | 1110111 
| 12   | mfcvtc.xw.fw.m  | 010110    | 0    | 0     | ts1   | 110    | lmul  | td  | 1110111 
| 13   | mfncvtc.fw.xq.m | 010111    | 1    | 0     | ts1   | 110    | lmul  | td  | 1110111 
| 14   | mfwcvtc.xq.fw.m | 010111    | 0    | 0     | ts1   | 110    | lmul  | td  | 1110111 
|===



== Intrinsic Examples

=== Matrix multiplication

```
void matmul_float16(c, a, b, m, k, n) {
    msettype(e16, m1);                          // use 16bit input matrix element
    for (i = 0; i < m; i += mtilem) {           // loop at dim m with tiling
        mtilem = msettile_m(m-i);
        for (j = 0; j < n; j += mtilen) {       // loop at dim n with tiling
            mtilen = msettile_n(n-j);

            out = mwsub_mm(out, out, m1)        // clear output reg
            for (s = 0; s < k; s += mtilek) {   // loop at dim k with tiling
                mtilek = msettile_k(k-s);
                
                tr1 = mlae16_m(&a[i][s], k*2);  // load left matrix a
                tr2 = mlbe16_m(&b[s][j], n*2);  // load right matrix b
                out = mfwma_mm(tr1, tr2);       // tiled matrix multiply,
                                                // double widen output
            }
           
            out = mfncvt_f_fw_m(out, m2);       // convert widen result
            msce16_m(out, &c[i][j], n*2);       // store to matrix c
        }
    }
}

```


=== Matrix multiplication with left matrix transposed

```
void matmul_a_tr_float16(c, a, b, m, k, n) {
    msettype(e16, m1);                          // use 16bit input matrix element
    for (i = 0; i < m; i += mtilem) {           // loop at dim m with tiling
        mtilem = msettile_m(m-i);
        for (j = 0; j < n; j += mtilen) {       // loop at dim n with tiling
            mtilen = msettile_n(n-j);

            out = mwsub_mm(out, out, m1)        // clear output reg
            for (s = 0; s < k; s += mtilek) {   // loop at dim k with tiling
                mtilek = msettile_k(k-s);
                
                tr1 = mlate16_m(&a[s][i], m*2); // load transposed left matrix a
                tr2 = mlbe16_m(&a[s][j], n*2);  // load right matrix b
                out = mfwma_mm(tr1, tr2);       // tiled matrix multiply,
                                                // double widen output
            }
           
            out = mfncvt_f_fw_m(out, m2);       // convert widen result
            msce16_m(out, &c[i][j], n*2);       // store to matrix c
        }
    }
}

```


=== Matrix transpose without multiplication

```
void mattrans_float16(out, in, h, w) {
    msettype(e16, m1);                          // use 16bit input matrix element

    for (i = 0; i < h; i += mtilem) {           // loop at dim m with tiling
        mtilem = msettile_m(h-i);
        for (j = 0; j < w; j += mtilek) {       // loop at dim k with tiling
            mtilek = msettile_k(w-j);

            tr_in = mlae16_m(&in[i][j], w*2);   // load input matrix
            msate16_m(tr_in, &out[j][i], h*2);  // store output matrix
        }
    }
}

```
